problem1

这道题很简单，没有用的代码很多，只需要关注关键的那一部分即可。主函数主要是调用fread读取了一个字

符串放在-0x110(%rbp)处然后调用了func函数。对func进行栈溢出攻击。func的栈帧如下。

|                  |            | payload                     |
| ---------------- | ---------- | --------------------------- |
| rbp + 8 返回地址 |            | **16 12 40 00 00 00 00 00** |
| rbp              |            | 01 01 01 01 01 01 01 01     |
| rbp-0x8          | 目的字符串 | 01 01 01 01 01 01 01 01     |
| rbp-0x18         | 源字符串   |                             |
| rbp-0x20 rsp     |            |                             |

****

func调用了strcpy函数，我们利用缓冲区溢出用ret跳转到0x401216处，这个地方调用了我们需要的函数打

印Yes!I like ICS!。所用的攻击输入及其对应位置已经画在表格里了。

![image-20241202190818473](C:\Users\Sun Guoze\AppData\Roaming\Typora\typora-user-images\image-20241202190818473.png)

problem2

这个题和problem1大同小异，主函数还是不用细看，大致也是用fread读文件到-0x120(%rbp)处，然后后调

用了func。func里调用了memcpy，memcpy有3个参数，-0x8(%rbp)目的位置，-0x18(%rbp)源位置，

$0x38是读取的字节数量，因为缓冲区很小所以这个大小绰绰有余了。栈帧如下



|                      |            | payload                 |
| -------------------- | ---------- | ----------------------- |
| **rbp + 8 返回地址** |            | 4c 12 40 00 00 00 00 00 |
| rbp                  |            | 00 00 00 00 00 00 00 00 |
| rbp-0x8              | 目的字符串 | 00 00 00 00 00 00 00 00 |
| rbp-0x18             | 源字符串   |                         |
| rbp-0x20 rsp         |            |                         |



我们利用缓冲区溢出用ret跳转到0x40124c处，这个地方调用了我们需要的函数打印Yes!I like ICS!。

ps:至于怎么找到的所需字符串凡是汇编代码从奇怪的地方搬运某个东西的时候用gdb的x/s

打印一下地址看看很容易找到。

![image-20241202190244047](C:\Users\Sun Guoze\AppData\Roaming\Typora\typora-user-images\image-20241202190244047.png)

problem3

这个题的主函数和前两道题一样，也是用fread读文件到-0x110(%rbp)处，然后后调用了func。func里调用

了memcpy，memcpy有3个参数，-0x20(%rbp)目的位置，-0x28(%rbp)源位置，$0x40是读取的字节数

量，这次需要巧妙利用一下缓冲区了。题目要求是打印字符串Your lucky number is 114,虽然很恶臭，但我

们经过一番苦心搜索，还是在func1里找到了所需字符串，这个字符串藏得很深，

0x63756c2072756f59 0x65626d756e20796b 0x3431312073692072这三个long被放在栈里，地址在

func1的-0x40(%rbp)，按照小端法转成字符串就是Your lucky number is 114。由于func1在一开始要检

查%edi这个寄存器里的值是否是0x72比较复杂，我想直接跳转到判断后面的0x40122b,这里有个小坑，由于

之前把rsp和rbp都破坏了，由于func2要给%rbp下面的栈空间赋值，要在攻击的func的pop %rbp处给%rbp

赋一个合适的值，否则会出现1.直接地址无效报错推出；2.储存的字符串被后面调用的puts函数的栈帧覆盖

导致输出乱码。而且这种操作会在exit函数中检测到栈破坏引发段错误，只能在gdb中才能正确输出，所以我

们用另一种方法。

直接上栈帧

| rbp -0x10     |          | payload:                |                                            |
| ------------- | -------- | ----------------------- | ------------------------------------------ |
| rbp +0x8      |          | 16 12 40 00 00 00 00 00 | func1的地址                                |
| rbp           | 返回地址 | 39 1a 40 00 00 00 00 00 | <jmp\_xs>的一部分代码                      |
| rbp -0x8      | 弹栈rbp  | 00 00 00 00 00 00 00 00 |                                            |
| rbp -0x10     |          | 00 00 00 00 00 00 00 00 |                                            |
| rbp -0x18     |          | 00 c3 00 00 00 00 00 00 | c3是ret                                    |
| rbp -0x20     | 目的地址 | BF 72 00 00 00 00 00 00 | BF 72 00 00 00 00 00 00 00是mov $0x72 $rdi |
| rbp -0x30 rsp |          |                         | 的机器码                                   |

****

我们这次直接把机器码注射到缓冲区里。观察到jmp\_xs这个函数会直接跳转到在func中储存的rsp+0x10，

也就是rbp -0x20处。我们在func的ret处跳转到0x401a39顺便可以稍微让rbp正常一点（此处是mov rsp

rbp），接下来就跳转到了rbp -0x20处。我们先执行mov $0x72 $rdi操作这样rdi就满足了条件，此时rsp在

rbp +0x8处，我们在这里放置func1的地址的地址，这样就可以用0xc3（ret）再次跳转到func2处，由于这

次func2是正常执行的，不会出现任何上面的问题，函数正常运行输出结果。附上截图。

![](C:\Users\Sun Guoze\Pictures\Screenshots\屏幕截图 2024-11-29 224726.png)

problem4

就像文档里写的那样，这个题不需要任何栈溢出攻击，甚至我觉得它应该放在bomblab里面。不管调用了凯

撒密码进行加密，但是加密的是提示用的字符串，因为与问题无关这里也不会分析。最后的问题是要我们输

入一个32位的无符号数，为什么是无符号是汇编里比较用的是jb。然后这个数字要比0xfffffffe大，那它就只

能是0xffffffff，后面又进行了奇怪的比较让这个数a减1，另一个从零开始的数字b+1直到b比0xfffffffe大，然

后判断a比0大其实是原地tp，我们直接输入-1就可以通关了。

至于要详细说一下金丝雀是怎么保护栈的我找个例子说一下。举func1为例

![屏幕截图 2024-11-29 225448](C:\Users\Sun Guoze\Pictures\Screenshots\屏幕截图 2024-11-29 225448.png)

| rbp          | 保存的rbp |
| ------------ | --------- |
| rbp -0x8     | 金丝雀值  |
| rbp-0x10 rsp | 栈顶      |
|              |           |

函数从%fs:28处取了随机的8个字节放在rbp-8处，我们无从直到金丝雀值到底是什么，因为rax^rax这个操

作会清空rax。当函数返回前会检测rbp-8处的金丝雀值和%fs:28处是否相等，如果不相等就说明栈帧已经被

破坏，上面的内容已经不安全，函数就不正常推出直接报\_\_stack\_chk\_fail的错误。这样就可以保证栈溢出攻

击会被检测到。

![image-20241202191006446](C:\Users\Sun Guoze\AppData\Roaming\Typora\typora-user-images\image-20241202191006446.png)
